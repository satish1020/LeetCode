# LeetCode
Solving LeetCode problems Via Javascript

Bind 75:

Array

- Two Sum - https://leetcode.com/problems/two-sum/
- Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
- Contains Duplicate - https://leetcode.com/problems/contains-duplicate/
- Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/
- Maximum Subarray - https://leetcode.com/problems/maximum-subarray/
- Maximum Product Subarray - https://leetcode.com/problems/maximum-product-subarray/
- Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
- Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/
- 3Sum - https://leetcode.com/problems/3sum/
- Container With Most Water - https://leetcode.com/problems/container-with-most-water/

---

Binary

- Sum of Two Integers - https://leetcode.com/problems/sum-of-two-integers/
- Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/
- Counting Bits - https://leetcode.com/problems/counting-bits/
- Missing Number - https://leetcode.com/problems/missing-number/
- Reverse Bits - https://leetcode.com/problems/reverse-bits/

---

Dynamic Programming

- Climbing Stairs - https://leetcode.com/problems/climbing-stairs/
- Coin Change - https://leetcode.com/problems/coin-change/
- Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/
- Longest Common Subsequence - 
- Word Break Problem - https://leetcode.com/problems/word-break/
- Combination Sum - https://leetcode.com/problems/combination-sum-iv/
- House Robber - https://leetcode.com/problems/house-robber/
- House Robber II - https://leetcode.com/problems/house-robber-ii/
- Decode Ways - https://leetcode.com/problems/decode-ways/
- Unique Paths - https://leetcode.com/problems/unique-paths/
- Jump Game - https://leetcode.com/problems/jump-game/

---

Graph

- Clone Graph - https://leetcode.com/problems/clone-graph/
- Course Schedule - https://leetcode.com/problems/course-schedule/
- Pacific Atlantic Water Flow - https://leetcode.com/problems/pacific-atlantic-water-flow/
- Number of Islands - https://leetcode.com/problems/number-of-islands/
- Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/
- Alien Dictionary (Leetcode Premium) - https://leetcode.com/problems/alien-dictionary/
- Graph Valid Tree (Leetcode Premium) - https://leetcode.com/problems/graph-valid-tree/
- Number of Connected Components in an Undirected Graph (Leetcode Premium) - https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/

---

Interval

- Insert Interval - https://leetcode.com/problems/insert-interval/
- Merge Intervals - https://leetcode.com/problems/merge-intervals/
- Non-overlapping Intervals - https://leetcode.com/problems/non-overlapping-intervals/
- Meeting Rooms (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms/
- Meeting Rooms II (Leetcode Premium) - https://leetcode.com/problems/meeting-rooms-ii/

---

Linked List

- Reverse a Linked List - https://leetcode.com/problems/reverse-linked-list/
- Detect Cycle in a Linked List - https://leetcode.com/problems/linked-list-cycle/
- Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/
- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
- Remove Nth Node From End Of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/
- Reorder List - https://leetcode.com/problems/reorder-list/

---

Matrix

- Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/
- Spiral Matrix - https://leetcode.com/problems/spiral-matrix/
- Rotate Image - https://leetcode.com/problems/rotate-image/
- Word Search - https://leetcode.com/problems/word-search/

---

String

- Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/
- Longest Repeating Character Replacement - https://leetcode.com/problems/longest-repeating-character-replacement/
- Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/
- Valid Anagram - https://leetcode.com/problems/valid-anagram/
- Group Anagrams - https://leetcode.com/problems/group-anagrams/
- Valid Parentheses - https://leetcode.com/problems/valid-parentheses/
- Valid Palindrome - https://leetcode.com/problems/valid-palindrome/
- Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/
- Palindromic Substrings - https://leetcode.com/problems/palindromic-substrings/
- Encode and Decode Strings (Leetcode Premium) - https://leetcode.com/problems/encode-and-decode-strings/

---

Tree

- Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/
- Same Tree - https://leetcode.com/problems/same-tree/
- Invert/Flip Binary Tree - https://leetcode.com/problems/invert-binary-tree/
- Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/
- Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/
- Serialize and Deserialize Binary Tree - https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
- Subtree of Another Tree - https://leetcode.com/problems/subtree-of-another-tree/
- Construct Binary Tree from Preorder and Inorder Traversal - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
- Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/
- Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/
- Lowest Common Ancestor of BST - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
- Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/
- Add and Search Word - https://leetcode.com/problems/add-and-search-word-data-structure-design/
- Word Search II - https://leetcode.com/problems/word-search-ii/

---

Heap

- Merge K Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/
- Top K Frequent Elements - https://leetcode.com/problems/top-k-frequent-elements/
- Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/

<!-- Git hub creating personal and work configs

 https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent

a. ssh-keygen -t ed25519 -C "cvsatish.net@gmail.com"
b. step a prompts for a path always choose :Â  ~/.ssh/id_ed25519_<some name if first time dontÂ give _name leave it> in our case we gave id_ed25519_personal.
c. And above command after giving successfullyÂ given path its asks for a pass phrase give any thing in this case we had given 12345678
d. after above steps now generated pub file we need to add using below commandÂ Â  Â Â ssh-add ~/.ssh/id_ed25519_personale. after creation copy the certificate using below commandÂ Â 
Â  Â  Â Â cat ~/.ssh/id_ed25519_personal.pub | pbcopyf.Â  AFter that the copied ssh key ned to enter in the gihubÂ go to github->topRight->dropdown->settings->SSH Key and GPG Keys -> Add New Key -> copy your key and save
g. After that please go to your config file in path ~/.SSH/CONFIG, create a domain for your personalÂ and give the path to the .pub file in ~/.ssh/.id_ed25519.pub file
Host github.com
Â  AddKeysToAgent yes
Â  UseKeychain yes
Â  IdentityFile ~/.ssh/id_ed25519_personal

h. test the ssh connectingÂ from your terminalÂ like belowÂ  Â  ssh -T git@github.com

vi ~/.ssh/config

to see configs in laptop vi ~/.ssh/config:
it gives list of ssh configs as below,
Host github.intuit.com
Â  AddKeysToAgent yes
Â  UseKeychain yes
Â  IdentityFile ~/.ssh/id_ed25519


Created a new personalÂ  config:
Host github.com
Â  AddKeysToAgent yes
Â  UseKeychain yes
Â  IdentityFile ~/.ssh/id_ed25519_personal -->

<!-- git commands -->
<!-- 1. ð ð¢ð­ ðð¢ðŸðŸ: Show file differences not yet staged.
2. ð ð¢ð­ ðœð¨ð¦ð¦ð¢ð­ -ðš -ð¦ "ðœð¨ð¦ð¦ð¢ð­ ð¦ðžð¬ð¬ðšð ðž": Commit all tracked changes with a message.
3. ð ð¢ð­ ðœð¨ð¦ð¦ð¢ð­ --ðšð¦ðžð§ð: Modify the last commit.
4. ð ð¢ð­ ð¬ð­ðšð­ð®ð¬: Show the state of your working directory.
5. ð ð¢ð­ ðšðð ðŸð¢ð¥ðž_ð©ðšð­ð¡: Add file(s) to the staging area.
6. ð ð¢ð­ ðœð¡ðžðœð¤ð¨ð®ð­ -ð› ð›ð«ðšð§ðœð¡_ð§ðšð¦ðž: Create and switch to a new branch.
7. ð ð¢ð­ ðœð¡ðžðœð¤ð¨ð®ð­ ð›ð«ðšð§ðœð¡_ð§ðšð¦ðž: Switch to an existing branch.
8. ð ð¢ð­ ðœð¡ðžðœð¤ð¨ð®ð­ <ðœð¨ð¦ð¦ð¢ð­>: Switches the working directory to a specific commit.
9. ð ð¢ð­ ð©ð®ð¬ð¡ ð¨ð«ð¢ð ð¢ð§ ð›ð«ðšð§ðœð¡_ð§ðšð¦ðž: Push a branch to a remote.
10. ð ð¢ð­ ð©ð®ð¥ð¥: Fetch and merge remote changes.
11. ð ð¢ð­ ðŸðžð­ðœð¡: Fetch changes from the remote repository without merging.
12. ð ð¢ð­ ð«ðžð›ðšð¬ðž -ð¢: Rebase interactively, rewrite commit history.
13. ð ð¢ð­ ð«ðžð›ðšð¬ðž ð›ð«ðšð§ðœð¡_ð§ðšð¦ðž: Rebase the current branch onto another branch.
14. ð ð¢ð­ ðœð¥ð¨ð§ðž: Create a local copy of a remote repo.
15. ð ð¢ð­ ð¦ðžð«ð ðž: Merge branches together.
16. ð ð¢ð­ ð¥ð¨ð  --ð¬ð­ðšð­: Show commit logs with stats.
17. ð ð¢ð­ ð¬ð­ðšð¬ð¡: Stash changes for later.
18. ð ð¢ð­ ð¬ð­ðšð¬ð¡ ð©ð¨ð©: Apply and remove stashed changes.
19. ð ð¢ð­ ð¬ð¡ð¨ð° ðœð¨ð¦ð¦ð¢ð­_ð¢ð: Show details about a commit.
20. ð ð¢ð­ ð«ðžð¬ðžð­ ð‡ð„ð€ðƒ~1: Undo the last commit, preserving changes locally.
21. ð ð¢ð­ ð›ð«ðšð§ðœð¡ -ðƒ ð›ð«ðšð§ðœð¡_ð§ðšð¦ðž: Delete a branch forcefully.
22. ð ð¢ð­ ð«ðžð¬ðžð­: Undo commits by moving branch reference.
23.  ð ð¢ð­ ð«ðžð¯ðžð«ð­ ðœð¨ð¦ð¦ð¢ð­_ð¢ð: Create a new commit that undoes the changes of a specific commit.
24. ð ð¢ð­ ðœð¡ðžð«ð«ð²-ð©ð¢ðœð¤ ðœð¨ð¦ð¦ð¢ð­_ð¢ð: Apply changes from a specific commit.
24. ð ð¢ð­ ð›ð«ðšð§ðœð¡: Lists branches.
26. ð ð¢ð­ ð«ðžð¬ðžð­ --ð¬ð¨ðŸð­ ð‡ð„ð€ðƒ^: Undo the last commit, but keep the changes.
27. ð ð¢ð­ ð«ðžð¬ðžð­ --ð¡ðšð«ð: Resets everything to a previous commit, erasing all uncommitted changes.
28: ð ð¢ð­ ð›ð«ðšð§ðœð¡ --ð¬ðžð­-ð®ð©ð¬ð­ð«ðžðšð¦-ð­ð¨ ð«ðžð¦ð¨ð­ðž_ð›ð«ðšð§ðœð¡: Sets the upstream branch to the specified remote branch. -->

<!-- Types of linked lists
Singly linked list

This is the most common type of linked list and the one that is given in the code above. In a singly linked list, each node only has a pointer to the next node. This means you can only move forward in the list when iterating. The pointer used to reference the next node is usually called next.

Let's say you want to add an element to a linked list so that it becomes the element at position i. To do this, you need to have a pointer to the element currently at position i - 1. The next element (currently at position i), call it x, will be pushed to the element at position i + 1 after the insertion. This means that x should become the next node to the one being added, and the node being added should become the next node to the one currently at i - 1. Here's some code and images demonstrating: -->

<!-- class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// Let prevNode be the node at position i - 1
let addNode = (prevNode, nodeToAdd) => {
    nodeToAdd.next = prevNode.next;
    prevNode.next = nodeToAdd;
} -->

<!-- class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// Let prevNode be the node at position i - 1
let addNode = (prevNode, nodeToAdd) => {
    nodeToAdd.next = prevNode.next;
    prevNode.next = nodeToAdd;
} -->

<!-- Note: it is unusual that you will have a pointer to the node at the position before where you want to perform an operation, but we are writing these functions as a demonstration. Typically you will be doing these operations on the fly, as you iterate through the list. If you don't have a pointer to the desired position at all, you will need to iterate from the head until you are at the desired position, which means the operation would be 
O
(
n
)
O(n). If you have the pointer already, it's 
O
(
1
)
O(1). -->
<!-- 
Let's say you want to delete the element at position i. Again, you need to have a pointer to the element currently at position i - 1. The element at position i + 1, call it x, will be shifted over to be at position i after the deletion. Therefore, you should set x as the next node to the element currently at position i - 1. Here's some code and images demonstrating: -->

<!-- class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// Let prevNode be the node at position i - 1
let deleteNode = prevNode => {
    prevNode.next = prevNode.next.next;
} -->

<!-- prevNode.next is the node being deleted. prevNode.next.next is the node after that which should be kept. We change the next pointer of prevNode to point at that node instead of the one being deleted.

Because the node being deleted could only have been reached from prevNode and we have now severed that connection, it is no longer part of the list. -->

<!-- As mentioned before, when you have a reference to the node at i - 1, then insertion and deletion is 
O
(
1
)
O(1). However, without that reference, you need to obtain the reference by iterating from the head, which for an arbitrary position is 
O
(
n
)
O(n). -->

<!-- Doubly linked list

A doubly linked list is like a singly linked list, but each node also contains a pointer to the previous node. This pointer is usually called prev, and it allows iteration in both directions.

In a singly linked list, we needed a reference to the node at i - 1 if we wanted to add or remove at i. This is because we needed to perform operations on the prevNode. With a doubly linked list, we only need a reference to the node at i. This is because we can simply reference the prev pointer of that node to get the node at i - 1, and then do the exact same operations as above.

With a doubly linked list, we need to do extra work to also update the prev pointers. -->

<!-- class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
        this.prev = null;
    }
}

let addNode = (node, nodeToAdd) => {
    let prevNode = node.prev;
    nodeToAdd.next = node;
    nodeToAdd.prev = prevNode;
    prevNode.next = nodeToAdd;
    node.prev = nodeToAdd;
}

let deleteNode = node => {
    let prevNode = node.prev;
    let nextNode = node.next;
    prevNode.next = nextNode;
    nextNode.prev = prevNode;
} -->



<!-- 2130. Maximum Twin Sum of a Linked List
Solved
Medium
Topics
Companies
Hint
In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.

For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.

Given the head of a linked list with even length, return the maximum twin sum of the linked list.

 

Example 1:


Input: head = [5,4,2,1]
Output: 6
Explanation:
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
Example 2:


Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 
Example 3:


Input: head = [1,100000]
Output: 100001
Explanation:
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
 

Constraints:

The number of nodes in the list is an even integer in the range [2, 105].
1 <= Node.val <= 105 -->